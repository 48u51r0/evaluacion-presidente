} else {
paste0("Levene test: Homoskedástico al ", significance, ". Resultado Chow: probable")
}
aux2 <- if(fk$p.value < significance){
paste0("Fligner-Killeen: Heteroskedastico al ", significance, ". Resultado Chow: dudoso")
} else {
paste0("Fligner-Killeen: Homoskedástico al ", significance, ". Resultado Chow: probable")
}
salida <- list(Homoscedastico = list(levene = aux1, fk = aux2),
discontinuidad_sandwich = chow_linear,
discontinuidad_robust = chow_robust,
f = as.numeric(linear_chow$test$fstat),
fcritico = fcritico,
maxt_linear = broom::tidy(linear_chow_maxt) %>%
mutate(p.value = format(p.value, scientific = FALSE) %>%
as.numeric() %>%
round(3)
)%>%
select(Parameters = lhs, Beta = estimate, 'P value' = p.value),
maxt_robust = broom::tidy(robust_chow_maxt) %>%
inner_join(broom::tidy(confint(aux_robust_chow))) %>%
mutate(p.value = format(p.value, scientific = FALSE) %>%
as.numeric() %>%
round(3)
)%>%
select(Parameters = lhs, Beta = estimate, Lower = conf.low,
Upper = conf.high, 'P value' = p.value),
MM = broom::tidy(robust_completo) %>%
inner_join(broom::tidy(confint(aux_robust_completo))) %>%
mutate(p.value = format(p.value, scientific = FALSE) %>%
as.numeric() %>%
round(3)
) %>%
select(Parameters = contrast, Beta = estimate, SE = std.error,
Lower = conf.low, Upper = conf.high, 'P value' = p.value)
)
return(salida)
message(salida$Homoscedastico$levene)
message(salida$Homoscedastico$fk)
message("F = ", salida$f)
message("F critico = ", salida$fcritico)
message("Mediante estimador sandwich: ", discontinuidad_robust)
}
aux1 <- chow_dummy(df_3269, df_3271, mod3_restr, mod3_unrestr, significance = 0.01)
aux2 <- chow_dummy(df_3271, df_3273, mod3_restr, mod3_unrestr, significance = 0.01)
aux3 <- chow_dummy(df_3273, df_3277, mod3_restr, mod3_unrestr, significance = 0.01)
aux4 <- chow_dummy(df_3277, df_3279, mod3_restr, mod3_unrestr, significance = 0.01)
aux5 <- chow_dummy(df_3279, df_3281, mod3_restr, mod3_unrestr, significance = 0.01)
aux5$maxt_robust
aux4$maxt_robust
aux1$maxt_robust
data("bodyfat", package = "TH.data")
bodyfat
summary(lmod <- lm(DEXfat ~ ., data = bodyfat))
K <- cbind(0, diag(length(coef(lmod)) - 1))
rownames(K) <- names(coef(lmod))[-1]
lmod_glht <- glht(lmod, linfct = K)
summary(lmod_glht)
summary(lmod <- lm(DEXfat ~ ., data = bodyfat))
confint(lmod)
confint(lmod_glht)
summary(lmod_glht)
aux1$maxt_robust
aux2$maxt_robust
aux3$maxt_robust
aux4$maxt_robust
aux5$maxt_robust
chow_dummy <- function(pre,
post,
restricted,
unrestricted,
significance = .05){
#definimos el pooled data set con una dummy de punto discontinuidad
pooled <- bind_rows(pre, post) %>%
mutate(breakpoint = case_when(Periodo == min(Periodo) ~ 0,
Periodo == max(Periodo) ~ 1) %>%
factor()
)
#definimos los modelos lineales y robusto
lin_restr <- lm(restricted, data = pooled, weights = PESO)
lin_unrestr <- lm(unrestricted, data = pooled, weights = PESO)
robust_unrestr <- robustbase::lmrob(unrestricted, data = pooled, weights = PESO)
#definimos las matrices de hipótesis (multcomp)
k_restr <- read_rds("k_chow.rds") #Solo los coeficientes con la dummy son = 0
k_unrestr <- cbind(diag(length(coef(robust_unrestr)))) #todos los coeficientes = 0
rownames(k_unrestr) <- names(coef(robust_unrestr))
#Definimos los objeto multcomp del test de Chow
#los modelos chow se utilizan para la inferencia multiple de las variables dummy
#usamos dos alternativas robustas ante la heteroscedasticidad:
#sandwich y estimador MM (regresion robusta)
aux_linear_chow <- glht(lin_unrestr, linfct = k_restr, vcov =sandwich)
aux_robust_chow <- glht(robust_unrestr, linfct = k_restr)
#Calculamos los F-statistic del test chow con dummy
linear_chow <- summary(aux_linear_chow, test = Ftest())
robust_chow <- summary(aux_robust_chow, test =Ftest())
#Calculamos el valor F-crítico. No importa si usamos linear_chow o robust_chow
fcritico <- qf(1-significance,
linear_chow$test$df[1],
linear_chow$test$df[2])
#otra alternativa es simplemente realizar la inferencia múltiple mediante
#el max-t test descrito por Hothorn, Bretz y Westfall(2008)
linear_chow_maxt <- summary(aux_linear_chow)
robust_chow_maxt <- summary(aux_robust_chow)
#Contraste de hipótesis para los dos métodos alternativos:robust and sandwich
chow_linear <- if_else(linear_chow$test$fstat > fcritico,
paste0("Hay discontinuidad en la regresión al ",
significance),
paste0("No hay discontinuidad en la regresión al",
significance)
)
chow_robust <- if_else(robust_chow$test$fstat > fcritico,
paste0("Hay discontinuidad en la regresión al ",
significance),
paste0("No hay discontinuidad en la regresión al ",
significance)
)
#los modelos completo se utlizarán para realizar la regresión, obtener
#sus coeficientes, SE y p-value
#también se utiliza el ajuste multcomp de inferencia múltiple
#y las dos aproximaciones a la heteroscedasticity sandwich y robust MM
aux_linear_completo <- glht(lin_unrestr, linfct = k_unrestr, vcov= sandwich)
aux_robust_completo <- glht(robust_unrestr, linfct = k_unrestr)
linear_completo <- summary(aux_linear_completo)
robust_completo <- summary(aux_robust_completo)
aux <- data.frame(var = c(lin_unrestr$residuals,
lin_restr$residuals),
group = c(rep(0, nobs(lin_unrestr)),
rep(1, nobs(lin_restr))) %>%
factor()
)
levene <- car::leveneTest(aux$var, aux$group, center = median)
fk <- fligner.test(aux$var, aux$group)
aux1 <- if(levene$`Pr(>F)`[1] < significance){
paste0("Levene test: Heteroskedastico al ", significance, ". Resultado Chow: dudoso")
} else {
paste0("Levene test: Homoskedástico al ", significance, ". Resultado Chow: probable")
}
aux2 <- if(fk$p.value < significance){
paste0("Fligner-Killeen: Heteroskedastico al ", significance, ". Resultado Chow: dudoso")
} else {
paste0("Fligner-Killeen: Homoskedástico al ", significance, ". Resultado Chow: probable")
}
salida <- list(Homoscedastico = list(levene = aux1, fk = aux2),
discontinuidad_sandwich = chow_linear,
discontinuidad_robust = chow_robust,
f = as.numeric(linear_chow$test$fstat),
fcritico = fcritico,
maxt_linear = broom::tidy(linear_chow_maxt) %>%
mutate(p.value = format(p.value, scientific = FALSE) %>%
as.numeric() %>%
round(3)
)%>%
select(Parameters = lhs, Beta = estimate, 'P value' = p.value),
maxt_robust = broom::tidy(robust_chow_maxt) %>%
inner_join(broom::tidy(confint(aux_robust_chow,
level = 1 - significance))) %>%
mutate(p.value = format(p.value, scientific = FALSE) %>%
as.numeric() %>%
round(3)
)%>%
select(Parameters = lhs, Beta = estimate, Lower = conf.low,
Upper = conf.high, 'P value' = p.value),
MM = broom::tidy(robust_completo) %>%
inner_join(broom::tidy(confint(aux_robust_completo,
level = 1 - significance))) %>%
mutate(p.value = format(p.value, scientific = FALSE) %>%
as.numeric() %>%
round(3)
) %>%
select(Parameters = contrast, Beta = estimate, SE = std.error,
Lower = conf.low, Upper = conf.high, 'P value' = p.value)
)
return(salida)
message(salida$Homoscedastico$levene)
message(salida$Homoscedastico$fk)
message("F = ", salida$f)
message("F critico = ", salida$fcritico)
message("Mediante estimador sandwich: ", discontinuidad_robust)
}
aux1 <- chow_dummy(df_3269, df_3271, mod3_restr, mod3_unrestr, significance = 0.01)
aux2 <- chow_dummy(df_3271, df_3273, mod3_restr, mod3_unrestr, significance = 0.01)
aux3 <- chow_dummy(df_3273, df_3277, mod3_restr, mod3_unrestr, significance = 0.01)
aux4 <- chow_dummy(df_3277, df_3279, mod3_restr, mod3_unrestr, significance = 0.01)
aux5 <- chow_dummy(df_3279, df_3281, mod3_restr, mod3_unrestr, significance = 0.01)
aux1$maxt_robust
aux2$maxt_robust
aux2$maxt_robust
aux4$maxt_robust
aux4$discontinuidad_robust
aux1$Homoscedastico
aux2$Homoscedastico
aux3$Homoscedastico
aux4$Homoscedastico
aux5$Homoscedastico
how_dummy <- function(pre,
post,
restricted,
unrestricted,
significance = .05){
#definimos el pooled data set con una dummy de punto discontinuidad
pooled <- bind_rows(pre, post) %>%
mutate(breakpoint = case_when(Periodo == min(Periodo) ~ 0,
Periodo == max(Periodo) ~ 1) %>%
factor()
)
#definimos los modelos lineales y robusto
lin_restr_pre <- lm(restricted, data = pre, weights = PESO)
lin_restr_post <- lm(restricted, data = post, weights = PESO)
lin_unrestr <- lm(unrestricted, data = pooled, weights = PESO)
robust_unrestr <- robustbase::lmrob(unrestricted, data = pooled, weights = PESO)
#definimos las matrices de hipótesis (multcomp)
k_restr <- read_rds("k_chow.rds") #Solo los coeficientes con la dummy son = 0
k_unrestr <- cbind(diag(length(coef(robust_unrestr)))) #todos los coeficientes = 0
rownames(k_unrestr) <- names(coef(robust_unrestr))
#Definimos los objeto multcomp del test de Chow
#los modelos chow se utilizan para la inferencia multiple de las variables dummy
#usamos dos alternativas robustas ante la heteroscedasticidad:
#sandwich y estimador MM (regresion robusta)
aux_linear_chow <- glht(lin_unrestr, linfct = k_restr, vcov =sandwich)
aux_robust_chow <- glht(robust_unrestr, linfct = k_restr)
#Calculamos los F-statistic del test chow con dummy
linear_chow <- summary(aux_linear_chow, test = Ftest())
robust_chow <- summary(aux_robust_chow, test =Ftest())
#Calculamos el valor F-crítico. No importa si usamos linear_chow o robust_chow
fcritico <- qf(1-significance,
linear_chow$test$df[1],
linear_chow$test$df[2])
#otra alternativa es simplemente realizar la inferencia múltiple mediante
#el max-t test descrito por Hothorn, Bretz y Westfall(2008)
linear_chow_maxt <- summary(aux_linear_chow)
robust_chow_maxt <- summary(aux_robust_chow)
#Contraste de hipótesis para los dos métodos alternativos:robust and sandwich
chow_linear <- if_else(linear_chow$test$fstat > fcritico,
paste0("Hay discontinuidad en la regresión al ",
significance),
paste0("No hay discontinuidad en la regresión al",
significance)
)
chow_robust <- if_else(robust_chow$test$fstat > fcritico,
paste0("Hay discontinuidad en la regresión al ",
significance),
paste0("No hay discontinuidad en la regresión al ",
significance)
)
#los modelos completo se utlizarán para realizar la regresión, obtener
#sus coeficientes, SE y p-value
#también se utiliza el ajuste multcomp de inferencia múltiple
#y las dos aproximaciones a la heteroscedasticity sandwich y robust MM
aux_linear_completo <- glht(lin_unrestr, linfct = k_unrestr, vcov= sandwich)
aux_robust_completo <- glht(robust_unrestr, linfct = k_unrestr)
linear_completo <- summary(aux_linear_completo)
robust_completo <- summary(aux_robust_completo)
aux <- data.frame(var = c(lin_restr_pre$residuals,
lin_restr_post$residuals),
group = c(rep(0, nobs(lin_restr_pre)),
rep(1, nobs(lin_restr_post))) %>%
factor()
)
levene <- car::leveneTest(aux$var, aux$group, center = median)
fk <- fligner.test(aux$var, aux$group)
aux1 <- if(levene$`Pr(>F)`[1] < significance){
paste0("Levene test: Heteroskedastico al ", significance, ". Resultado Chow: dudoso")
} else {
paste0("Levene test: Homoskedástico al ", significance, ". Resultado Chow: probable")
}
aux2 <- if(fk$p.value < significance){
paste0("Fligner-Killeen: Heteroskedastico al ", significance, ". Resultado Chow: dudoso")
} else {
paste0("Fligner-Killeen: Homoskedástico al ", significance, ". Resultado Chow: probable")
}
salida <- list(Homoscedastico = list(levene = aux1, fk = aux2),
discontinuidad_sandwich = chow_linear,
discontinuidad_robust = chow_robust,
f = as.numeric(linear_chow$test$fstat),
fcritico = fcritico,
maxt_linear = broom::tidy(linear_chow_maxt) %>%
mutate(p.value = format(p.value, scientific = FALSE) %>%
as.numeric() %>%
round(3)
)%>%
select(Parameters = lhs, Beta = estimate, 'P value' = p.value),
maxt_robust = broom::tidy(robust_chow_maxt) %>%
inner_join(broom::tidy(confint(aux_robust_chow,
level = 1 - significance))) %>%
mutate(p.value = format(p.value, scientific = FALSE) %>%
as.numeric() %>%
round(3)
)%>%
select(Parameters = lhs, Beta = estimate, Lower = conf.low,
Upper = conf.high, 'P value' = p.value),
MM = broom::tidy(robust_completo) %>%
inner_join(broom::tidy(confint(aux_robust_completo,
level = 1 - significance))) %>%
mutate(p.value = format(p.value, scientific = FALSE) %>%
as.numeric() %>%
round(3)
) %>%
select(Parameters = contrast, Beta = estimate, SE = std.error,
Lower = conf.low, Upper = conf.high, 'P value' = p.value)
)
return(salida)
message(salida$Homoscedastico$levene)
message(salida$Homoscedastico$fk)
message("F = ", salida$f)
message("F critico = ", salida$fcritico)
message("Mediante estimador sandwich: ", discontinuidad_robust)
}
a
# Aplicamos chow_dummy a cada transición de periodo
aux1 <- chow_dummy(df_3269, df_3271, mod3_restr, mod3_unrestr, significance = 0.01)
aux1$Homoscedastico
aux2$Homoscedastico
aux3$Homoscedastico
aux4$Homoscedastico
aux5$Homoscedastico
df_pre <- df_3269
df_post <- df_3271
f1 <- chow(pre = df_pre, post = df_post, formula = mod3, significance = 0.01) #Stable. Probable
#3269 - 3271
df_pre <- df_3269
df_post <- df_3271
f1 <- chow(pre = df_pre, post = df_post, formula = mod3, significance = 0.01) #Stable. Probable
#3271 - 3273
df_pre <- df_3271
df_post <- df_3273
f2 <- chow(pre = df_pre, post = df_post, formula = mod3, significance = 0.01) #Stable. Probable
#3273 - 3277
df_pre <- df_3273
df_post <- df_3277
f3  <- chow(pre = df_pre, post = df_post, formula = mod3, significance = 0.01) #Stable. Probable
#3277 - 3279
df_pre <- df_3277
df_post <- df_3279
f4 <- chow(pre = df_pre, post = df_post, formula = mod3, significance = 0.01) #Stable. Probable
#3279 - 3281
df_pre <- df_3279
df_post <- df_3281
f5 <- chow(pre = df_pre, post = df_post, formula = mod3, significance = 0.01) #Stable. Probable
aux3$Homoscedastico
df_pre <- df_3277
df_post <- df_3279
f4 <- chow(pre = df_pre, post = df_post, formula = mod3, significance = 0.01) #Stable. Probable
aux4 <- chow_dummy(df_3277, df_3279, mod3_restr, mod3_unrestr, significance = 0.01)
aux4$Homoscedastico
pre <- lm(mod3_unrestr, df_3277, weights = PESO)
pre <- lm(mod3_restr, df_3277, weights = PESO)
weighted.residuals()
weighted.residuals(pre)
pre$residuals
identical(pre$residuals, weighted.residuals(pre))
identical(pre$residuals, pre$residuals)
post <- lm(mod3_restr, df_3279, weights = PESO)
aux <- data.frame(var = c(pre$residuals, post$residuals),
group = c(rep(0, nobs(pre)), rep(1, nobs(post))) %>%
factor()
)
car::leveneTest(aux$var, aux$group, center = median)
fligner.test(aux$var, aux$group)
pre <- df_3277
post <- df_3279
restricted <- mod3_restr
unrestricted <- mod3_unrestr
significance <- .01
pooled <- bind_rows(pre, post) %>%
mutate(breakpoint = case_when(Periodo == min(Periodo) ~ 0,
Periodo == max(Periodo) ~ 1) %>%
factor()
)
#definimos los modelos lineales y robusto
lin_restr_pre <- lm(restricted, data = pre, weights = PESO)
lin_restr_post <- lm(restricted, data = post, weights = PESO)
aux <- data.frame(var = c(lin_restr_pre$residuals,
lin_restr_post$residuals),
group = c(rep(0, nobs(lin_restr_pre)),
rep(1, nobs(lin_restr_post))) %>%
factor()
)
levene <- car::leveneTest(aux$var, aux$group, center = median)
fk <- fligner.test(aux$var, aux$group)
aux1 <- if(levene$`Pr(>F)`[1] < significance){
cat("Levene test: Heteroskedastico al ", significance, ". Resultado Chow: dudoso\n")
} else {
cat("Levene test: Homoskedástico al ", significance, ". Resultado Chow: probable\n")
}
aux2 <- if(fk$p.value < significance){
cat("Fligner-Killeen: Heteroskedastico al ", significance, ". Resultado Chow: dudoso\n")
} else {
cat("Fligner-Killeen: Homoskedástico al ", significance, ". Resultado Chow: probable\n")
}
chow_dummy <- function(pre,
post,
restricted,
unrestricted,
significance = .05){
#definimos el pooled data set con una dummy de punto discontinuidad
pooled <- bind_rows(pre, post) %>%
mutate(breakpoint = case_when(Periodo == min(Periodo) ~ 0,
Periodo == max(Periodo) ~ 1) %>%
factor()
)
#definimos los modelos lineales y robusto
lin_restr_pre <- lm(restricted, data = pre, weights = PESO)
lin_restr_post <- lm(restricted, data = post, weights = PESO)
lin_unrestr <- lm(unrestricted, data = pooled, weights = PESO)
robust_unrestr <- robustbase::lmrob(unrestricted, data = pooled, weights = PESO)
#definimos las matrices de hipótesis (multcomp)
k_restr <- read_rds("k_chow.rds") #Solo los coeficientes con la dummy son = 0
k_unrestr <- cbind(diag(length(coef(robust_unrestr)))) #todos los coeficientes = 0
rownames(k_unrestr) <- names(coef(robust_unrestr))
#Definimos los objeto multcomp del test de Chow
#los modelos chow se utilizan para la inferencia multiple de las variables dummy
#usamos dos alternativas robustas ante la heteroscedasticidad:
#sandwich y estimador MM (regresion robusta)
aux_linear_chow <- glht(lin_unrestr, linfct = k_restr, vcov =sandwich)
aux_robust_chow <- glht(robust_unrestr, linfct = k_restr)
#Calculamos los F-statistic del test chow con dummy
linear_chow <- summary(aux_linear_chow, test = Ftest())
robust_chow <- summary(aux_robust_chow, test =Ftest())
#Calculamos el valor F-crítico. No importa si usamos linear_chow o robust_chow
fcritico <- qf(1-significance,
linear_chow$test$df[1],
linear_chow$test$df[2])
#otra alternativa es simplemente realizar la inferencia múltiple mediante
#el max-t test descrito por Hothorn, Bretz y Westfall(2008)
linear_chow_maxt <- summary(aux_linear_chow)
robust_chow_maxt <- summary(aux_robust_chow)
#Contraste de hipótesis para los dos métodos alternativos:robust and sandwich
chow_linear <- if_else(linear_chow$test$fstat > fcritico,
paste0("Hay discontinuidad en la regresión al ",
significance),
paste0("No hay discontinuidad en la regresión al",
significance)
)
chow_robust <- if_else(robust_chow$test$fstat > fcritico,
paste0("Hay discontinuidad en la regresión al ",
significance),
paste0("No hay discontinuidad en la regresión al ",
significance)
)
#los modelos completo se utlizarán para realizar la regresión, obtener
#sus coeficientes, SE y p-value
#también se utiliza el ajuste multcomp de inferencia múltiple
#y las dos aproximaciones a la heteroscedasticity sandwich y robust MM
aux_linear_completo <- glht(lin_unrestr, linfct = k_unrestr, vcov= sandwich)
aux_robust_completo <- glht(robust_unrestr, linfct = k_unrestr)
linear_completo <- summary(aux_linear_completo)
robust_completo <- summary(aux_robust_completo)
aux <- data.frame(var = c(lin_restr_pre$residuals,
lin_restr_post$residuals),
group = c(rep(0, nobs(lin_restr_pre)),
rep(1, nobs(lin_restr_post))) %>%
factor()
)
levene <- car::leveneTest(aux$var, aux$group, center = median)
fk <- fligner.test(aux$var, aux$group)
aux1 <- if(levene$`Pr(>F)`[1] < significance){
cat("Levene test: Heteroskedastico al ", significance, ". Resultado Chow: dudoso\n")
} else {
cat("Levene test: Homoskedástico al ", significance, ". Resultado Chow: probable\n")
}
aux2 <- if(fk$p.value < significance){
cat("Fligner-Killeen: Heteroskedastico al ", significance, ". Resultado Chow: dudoso\n")
} else {
cat("Fligner-Killeen: Homoskedástico al ", significance, ". Resultado Chow: probable\n")
}
salida <- list(Homoscedastico = list(levene = aux1, fk = aux2),
discontinuidad_sandwich = chow_linear,
discontinuidad_robust = chow_robust,
f = as.numeric(linear_chow$test$fstat),
fcritico = fcritico,
maxt_linear = broom::tidy(linear_chow_maxt) %>%
mutate(p.value = format(p.value, scientific = FALSE) %>%
as.numeric() %>%
round(3)
)%>%
select(Parameters = lhs, Beta = estimate, 'P value' = p.value),
maxt_robust = broom::tidy(robust_chow_maxt) %>%
inner_join(broom::tidy(confint(aux_robust_chow,
level = 1 - significance))) %>%
mutate(p.value = format(p.value, scientific = FALSE) %>%
as.numeric() %>%
round(3)
)%>%
select(Parameters = lhs, Beta = estimate, Lower = conf.low,
Upper = conf.high, 'P value' = p.value),
MM = broom::tidy(robust_completo) %>%
inner_join(broom::tidy(confint(aux_robust_completo,
level = 1 - significance))) %>%
mutate(p.value = format(p.value, scientific = FALSE) %>%
as.numeric() %>%
round(3)
) %>%
select(Parameters = contrast, Beta = estimate, SE = std.error,
Lower = conf.low, Upper = conf.high, 'P value' = p.value)
)
return(salida)
message(salida$Homoscedastico$levene)
message(salida$Homoscedastico$fk)
message("F = ", salida$f)
message("F critico = ", salida$fcritico)
message("Mediante estimador sandwich: ", discontinuidad_robust)
}
aux4 <- chow_dummy(df_3277, df_3279, mod3_restr, mod3_unrestr, significance = 0.01)
aux1 <- chow_dummy(df_3269, df_3271, mod3_restr, mod3_unrestr, significance = 0.01)
aux2 <- chow_dummy(df_3271, df_3273, mod3_restr, mod3_unrestr, significance = 0.01)
aux3 <- chow_dummy(df_3273, df_3277, mod3_restr, mod3_unrestr, significance = 0.01)
aux4 <- chow_dummy(df_3277, df_3279, mod3_restr, mod3_unrestr, significance = 0.01)
aux5 <- chow_dummy(df_3279, df_3281, mod3_restr, mod3_unrestr, significance = 0.01)
iris
fit1 <- lm(Sepal.Length ~ Petal.Width, data = iris)
names(fit1$model)[1]
robust_unrestr
