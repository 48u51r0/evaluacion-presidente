size = FALSE)+
theme(legend.title = element_blank())+
facet_wrap(~transition)+
opts(
legend.position = c(0.8, 0.2), # c(0,0) bottom left, c(1,1) top-right.
legend.background = theme_rect(fill = "white", colour = NA)
)
#-----------------Visualización------------------------------------------------
tmp$df %>%
ggplot(aes(x=x, y=predicted, group = group, color= group))+
geom_line() +
geom_ribbon(aes(ymin= conf.low, ymax=conf.high, fill=group), alpha= .3, colour=NA)+
guides(color = FALSE,
size = FALSE)+
theme(legend.title = element_blank())+
facet_wrap(~transition)+
theme(legend.position = c(0.8, 0.2)
,legend.background = element_rect(fill = "white", colour = NA))
#-----------------Visualización------------------------------------------------
tmp$df %>%
ggplot(aes(x=x, y=predicted, group = group, color= group))+
geom_line() +
geom_ribbon(aes(ymin= conf.low, ymax=conf.high, fill=group), alpha= .3, colour=NA)+
guides(color = FALSE,
size = FALSE)+
theme(legend.title = element_blank())+
facet_wrap(~transition)+
theme(legend.position = c(0.9, 0.3)
,legend.background = element_rect(fill = "white", colour = NA))
#-----------------Visualización------------------------------------------------
tmp$df %>%
ggplot(aes(x=x, y=predicted, group = group, color= group))+
geom_line() +
geom_ribbon(aes(ymin= conf.low, ymax=conf.high, fill=group), alpha= .3, colour=NA)+
guides(color = FALSE,
size = FALSE)+
theme(legend.title = element_blank())+
facet_wrap(~transition)+
theme(legend.position = c(0.85, 0.25)
,legend.background = element_rect(fill = "white", colour = NA))
View(head(df_3269))
install.packages("rcompanion")
library(rcompanion)
groupwiseMean(ideol_pers ~1, )
groupwiseMean(ideol_pers ~1, data = df_3269, weights =PESO )
groupwiseMean(ideol_pers ~1, data = df_3269)
groupwiseMean(ideol_pers ~1, data = df_3271)
groupwiseMean(ideol_pers ~1, data = df_3273)
groupwiseMean(ideol_pers ~1, data = df_3277)
groupwiseMean(ideol_pers ~1, data = df_3279)
install.packages("boot")
install.packages("boot")
library(boot)
Mboot_w = boot(df_3269$ideol_pers * df_3269$PESO, function(x,i) mean(x[i]), R=10000)
Mboot_w
boot.ci(Mboot_w, conf = 0.95,  type = c("norm", "basic" ,"perc"))
boot(df_3269$ideol_pers, statistic = mean, weights = df_3269$PESO)
boot(df_3269$ideol_pers, statistic = mean, weights = df_3269$PESO, R = 10000)
Mboot_w = boot(df_3269$ideol_pers * df_3269$PESO, function(x,i) mean(x[i]), R=100000)
Mboot_w
boot.ci(Mboot_w, conf = 0.95,  type = c("norm", "basic" ,"perc"))
weighted.mean(df_3269$ideol_pers, df_3269$PESO, na.rm = T)
sd <- weighted.sd(df_3269$ideol_pers, df_3269$PESO, na.rm = T)
weighted.sd <- function(x, w, na.rm = FALSE) {
if (na.rm) {
w <- w[i <- !is.na(x)]
x <- x[i]
}
var.w <- (sum(w*x^2) * sum(w) - sum(w*x)^2) / (sum(w)^2 - sum(w^2))
sqrt(var.w)
}
sd <- weighted.sd(df_3269$ideol_pers, df_3269$PESO, na.rm = T)
se <- sd/sqrt(length(df_3269$ideol_pers[!is.na(df_3269$ideol_pers)]))
4.584237 + 1.96 * se
4.584237 - 1.96 * se
qnorm(0.05)
qnorm(0.05,sd = sd, mean = 4.584237)
pnorm(0.05,sd = sd, mean = 4.584237)
source("Scripts/Cargar_datos.R")
source("Scripts/Cargar_datos.R")
#-----------------Planteamiento de modelos-------------------------------------
mod_vacio <- "eval_pres ~ man + higher_educ+ welloff"
mod_simple <- "eval_pres ~ ideol_GMC + man + higher_educ + welloff"
mod_completo <- "eval_pres ~ ideol_GMC + ideol_2 + ideol_3 + man+higher_educ+welloff"
datos <- bind_rows(df_3269, df_3271, df_3273, df_3277, df_3279, df_3281)
# ponderamos los pesos de cada dataset por la contribucion de cada
# conjunto de datos al total
aux <- numeric()
for (i in 1:6) {
aux[i] <- sum(datos$PESO[datos$Periodo== i])/(sum(datos$PESO))
}
datos <- datos %>%
mutate(ponderacion = case_when(Periodo == 1 ~ aux[1],
Periodo == 2 ~ aux[2],
Periodo == 3 ~ aux[3],
Periodo == 4 ~ aux[4],
Periodo == 5 ~ aux[5],
Periodo == 6 ~ aux[6]),
w = PESO * ponderacion)
`Vacío` <- lmrob(mod_vacio,
data = datos,
weights = w)
Simple <- lmrob(mod_simple,
data = datos,
weights = w)
Completo <- lmrob(mod_completo,
data = datos,
weights = w)
#-----------------Summary------------------------------------------------------
# cambiamos los nombres de los coeficientes de las regresiones para que
# salgan correctamente en el output
names(`Vacío`$coefficients)[1]<- "Intercepto"
names(`Vacío`$coefficients)[2]<- "Hombre"
names(`Vacío`$coefficients)[3]<- "No universitario"
names(`Vacío`$coefficients)[4]<- "No acomodado"
names(Simple$coefficients)[1]<- "Intercepto"
names(Simple$coefficients)[2]<- "Ideología"
names(Simple$coefficients)[3]<- "Hombre"
names(Simple$coefficients)[4]<- "No universitario"
names(Simple$coefficients)[5]<- "No acomodado"
names(Completo$coefficients)[1]<- "Intercepto"
names(Completo$coefficients)[2]<- "Ideología"
names(Completo$coefficients)[3]<- "Ideología (cuadrático)"
names(Completo$coefficients)[4]<- "Ideología (cúbico)"
names(Completo$coefficients)[5]<- "Hombre"
names(Completo$coefficients)[6]<- "No universitario"
names(Completo$coefficients)[7]<- "No acomodado"
stargazer(`Vacío`, Simple, Completo, type = "text",
intercept.bottom = FALSE, model.names = TRUE,
object.names = TRUE, model.numbers = FALSE,
out = "tresmodelos.html")
class(df_3269$RV)
unique(df_3269$RV)
mod_vacio <- "eval_pres ~ man + higher_educ+ welloff"
mod_simple <- "eval_pres ~ RV + man + higher_educ + welloff"
mod_completo <- "eval_pres ~ ideol_GMC + ideol_2 + ideol_3 + man+higher_educ+welloff"
datos <- bind_rows(df_3269, df_3271, df_3273, df_3277, df_3279, df_3281)
# ponderamos los pesos de cada dataset por la contribucion de cada
# conjunto de datos al total
aux <- numeric()
for (i in 1:6) {
aux[i] <- sum(datos$PESO[datos$Periodo== i])/(sum(datos$PESO))
}
datos <- datos %>%
mutate(ponderacion = case_when(Periodo == 1 ~ aux[1],
Periodo == 2 ~ aux[2],
Periodo == 3 ~ aux[3],
Periodo == 4 ~ aux[4],
Periodo == 5 ~ aux[5],
Periodo == 6 ~ aux[6]),
w = PESO * ponderacion)
`Vacío` <- lmrob(mod_vacio,
data = datos,
weights = w)
Simple <- lmrob(mod_simple,
data = datos,
weights = w)
Completo <- lmrob(mod_completo,
data = datos,
weights = w)
#-----------------Summary------------------------------------------------------
# cambiamos los nombres de los coeficientes de las regresiones para que
# salgan correctamente en el output
names(`Vacío`$coefficients)[1]<- "Intercepto"
names(`Vacío`$coefficients)[2]<- "Hombre"
names(`Vacío`$coefficients)[3]<- "No universitario"
names(`Vacío`$coefficients)[4]<- "No acomodado"
names(Simple$coefficients)[1]<- "Intercepto"
names(Simple$coefficients)[2]<- "Ideología"
names(Simple$coefficients)[3]<- "Hombre"
names(Simple$coefficients)[4]<- "No universitario"
names(Simple$coefficients)[5]<- "No acomodado"
names(Completo$coefficients)[1]<- "Intercepto"
names(Completo$coefficients)[2]<- "Ideología"
names(Completo$coefficients)[3]<- "Ideología (cuadrático)"
names(Completo$coefficients)[4]<- "Ideología (cúbico)"
names(Completo$coefficients)[5]<- "Hombre"
names(Completo$coefficients)[6]<- "No universitario"
names(Completo$coefficients)[7]<- "No acomodado"
stargazer(`Vacío`, Simple, Completo, type = "text",
intercept.bottom = FALSE, model.names = TRUE,
object.names = TRUE, model.numbers = FALSE,
out = "tresmodelos.html")
`Vacío` <- lmrob(mod_vacio,
data = datos,
weights = w)
Simple <- lmrob(mod_simple,
data = datos,
weights = w)
Completo <- lmrob(mod_completo,
data = datos,
weights = w)
stargazer(`Vacío`, Simple, Completo, type = "text",
intercept.bottom = FALSE, model.names = TRUE,
object.names = TRUE, model.numbers = FALSE,
out = "tresmodelos.html")
mod_vacio <- "eval_pres ~ man + higher_educ+ welloff"
mod_voto <- "eval_pres ~ RV + man + higher_educ + welloff"
mod_ideologia <- "eval_pres ~ ideol_GMC + ideol_2 + ideol_3 + man+higher_educ+welloff"
mod_completo <- "eval_pres ~ RV +ideol_GMC + ideol_2 + ideol_3 + man+higher_educ+welloff"
datos <- bind_rows(df_3269, df_3271, df_3273, df_3277, df_3279, df_3281)
# ponderamos los pesos de cada dataset por la contribucion de cada
# conjunto de datos al total
aux <- numeric()
for (i in 1:6) {
aux[i] <- sum(datos$PESO[datos$Periodo== i])/(sum(datos$PESO))
}
datos <- datos %>%
mutate(ponderacion = case_when(Periodo == 1 ~ aux[1],
Periodo == 2 ~ aux[2],
Periodo == 3 ~ aux[3],
Periodo == 4 ~ aux[4],
Periodo == 5 ~ aux[5],
Periodo == 6 ~ aux[6]),
w = PESO * ponderacion)
`Vacío` <- lmrob(mod_vacio,
data = datos,
weights = w)
Simple <- lmrob(mod_simple,
data = datos,
weights = w)
Completo <- lmrob(mod_completo,
data = datos,
weights = w)
stargazer(`Vacío`, Simple, Completo, type = "text",
intercept.bottom = FALSE, model.names = TRUE,
object.names = TRUE, model.numbers = FALSE,
out = "tresmodelos.html")
`Vacío` <- lmrob(mod_vacio,
data = datos,
weights = w)
Voto <- lmrob(mod_voto,
data = datos,
weights = w)
`Ideología` <- lmrob(mod_ideologia,
data = datos,
weights = w)
Completo <- lmrob(mod_completo,
data = datos,
weights = w)
stargazer(`Vacío`, `Ideología`, Voto, Completo, type = "text",
intercept.bottom = FALSE, model.names = TRUE,
object.names = TRUE, model.numbers = FALSE,
out = "tresmodelos.html")
library(rmarkdown)
library(knitr)
render("eqn-numbering.Rmd")
llibrary(rticles)
library(rticles)
rticles::elsevier_article()
rticles::rjournal_article()
elsevier_article()
elsevier_article
demo()
demo("is.things")
rm(list = ls())
# loading library of functions
source("Scripts/libs.R")
# Specify and install all the necessary packages
packages <- (c("weights","haven", "sandwich", "multcomp", "emmeans",
"tidyverse", "conflicted", "ggeffects", "splines",
"robustbase", "stargazer"))
install_pack(packages)
# Solve conflicts between packages
masked_functions()
# Load data sets the name of which starts with "df_"
load_data("df_")
# Clean auxiliary functions(lsf.str) and objects
rm(list = c(lsf.str(), "packages"))
View(df_3269)
mod3_unrestr <- "eval_pres ~ breakpoint*ideol_GMC + breakpoint*ideol_2 +
breakpoint*ideol_3 + man + higher_educ + welloff"
#the idea is to infer a "joint hypothesis" test of multiple restrictions.
#This joint hypothesis will be: all coefficients for terms containing the dummy
#are equal to 0. Thus, the restricted model will be:
mod3_restr <- "eval_pres ~ ideol_GMC + ideol_2 + ideol_3 + man+higher_educ+welloff"
#Dummy Chow function
chow_dummy <- function(pre,
post,
restricted,
unrestricted,
significance = .05){
#definimos el pooled data set con una dummy de punto discontinuidad
pooled <- bind_rows(pre, post) %>%
mutate(breakpoint = case_when(Periodo == min(Periodo) ~ 0,
Periodo == max(Periodo) ~ 1) %>%
factor()
)
#definimos los modelos lineales y robusto
lin_restr_pre <- lm(restricted, data = pre, weights = PESO)
lin_restr_post <- lm(restricted, data = post, weights = PESO)
lin_unrestr <- lm(unrestricted, data = pooled, weights = PESO)
robust_unrestr <- robustbase::lmrob(unrestricted, data = pooled, weights = PESO)
#definimos las matrices de hipótesis (multcomp)
k_restr <- read_rds("k_chow.rds") #Solo los coeficientes con la dummy son = 0
k_unrestr <- cbind(diag(length(coef(robust_unrestr)))) #todos los coeficientes = 0
rownames(k_unrestr) <- names(coef(robust_unrestr))
#Definimos los objeto multcomp del test de Chow
#los modelos chow se utilizan para la inferencia multiple de las variables dummy
#usamos dos alternativas robustas ante la heteroscedasticidad:
#sandwich y estimador MM (regresion robusta)
aux_linear_chow <- glht(lin_unrestr, linfct = k_restr, vcov =sandwich)
aux_robust_chow <- glht(robust_unrestr, linfct = k_restr)
#Calculamos los F-statistic del test chow con dummy
linear_chow <- summary(aux_linear_chow, test = Ftest())
robust_chow <- summary(aux_robust_chow, test =Ftest())
#Calculamos el valor F-crítico. No importa si usamos linear_chow o robust_chow
fcritico <- qf(1-significance,
linear_chow$test$df[1],
linear_chow$test$df[2])
#otra alternativa es simplemente realizar la inferencia múltiple mediante
#el max-t test descrito por Hothorn, Bretz y Westfall(2008)
linear_chow_maxt <- summary(aux_linear_chow)
robust_chow_maxt <- summary(aux_robust_chow)
#Contraste de hipótesis para los dos métodos alternativos:robust and sandwich
chow_linear <- if_else(linear_chow$test$fstat > fcritico,
paste0("Hay discontinuidad en la regresión al ",
significance),
paste0("No hay discontinuidad en la regresión al",
significance)
)
chow_robust <- if_else(robust_chow$test$fstat > fcritico,
paste0("Hay discontinuidad en la regresión al ",
significance),
paste0("No hay discontinuidad en la regresión al ",
significance)
)
#los modelos completo se utlizarán para realizar la regresión, obtener
#sus coeficientes, SE y p-value
#también se utiliza el ajuste multcomp de inferencia múltiple
#y las dos aproximaciones a la heteroscedasticity sandwich y robust MM
aux_linear_completo <- glht(lin_unrestr, linfct = k_unrestr, vcov= sandwich)
aux_robust_completo <- glht(robust_unrestr, linfct = k_unrestr)
linear_completo <- summary(aux_linear_completo)
robust_completo <- summary(aux_robust_completo)
aux <- data.frame(var = c(lin_restr_pre$residuals,
lin_restr_post$residuals),
group = c(rep(0, nobs(lin_restr_pre)),
rep(1, nobs(lin_restr_post))) %>%
factor()
)
levene <- car::leveneTest(aux$var, aux$group, center = median)
fk <- fligner.test(aux$var, aux$group)
aux1 <- if(levene$`Pr(>F)`[1] < significance){
paste0("Levene test: Heteroskedastico al ", significance, ". Resultado Chow: dudoso")
} else {
paste0("Levene test: Homoskedástico al ", significance, ". Resultado Chow: probable")
}
aux2 <- if(fk$p.value < significance){
paste0("Fligner-Killeen: Heteroskedastico al ", significance, ". Resultado Chow: dudoso")
} else {
paste0("Fligner-Killeen: Homoskedástico al ", significance, ". Resultado Chow: probable")
}
salida <- list(Homoscedastico = list(levene = aux1, fk = aux2),
discontinuidad_sandwich = chow_linear,
discontinuidad_robust = chow_robust,
f = as.numeric(linear_chow$test$fstat),
fcritico = fcritico,
maxt_linear = broom::tidy(linear_chow_maxt) %>%
inner_join(broom::tidy(confint(aux_linear_chow,
level = 1 - significance))) %>%
mutate(p.value = format(adj.p.value, scientific = FALSE) %>%
as.numeric() %>%
round(3)
)%>%
select('Parámetro' = contrast, Beta = estimate,
'Error Est.' = std.error, 'IC inferior' = conf.low,
'IC superior' = conf.high, 'P ajustado' = p.value),
maxt_robust = broom::tidy(robust_chow_maxt) %>%
inner_join(broom::tidy(confint(aux_robust_chow,
level = 1 - significance))) %>%
mutate(p.value = format(adj.p.value, scientific = FALSE) %>%
as.numeric() %>%
round(3)
) %>%
select('Parámetro' = contrast, Beta = estimate,
'Error Est.' = std.error, 'IC inferior' = conf.low,
'IC superior' = conf.high, 'P ajustado' = p.value),
MM = broom::tidy(robust_completo) %>%
inner_join(broom::tidy(confint(aux_robust_completo,
level = 1 - significance))) %>%
mutate(p.value = format(adj.p.value, scientific = FALSE) %>%
as.numeric() %>%
round(3)
) %>%
select('Parámetro' = contrast, Beta = estimate, 'Error Est.' = std.error,
'IC inferior' = conf.low, 'IC superior' = conf.high, 'P ajustado' = p.value)
)
return(salida)
message(salida$Homoscedastico$levene)
message(salida$Homoscedastico$fk)
message("F = ", salida$f)
message("F critico = ", salida$fcritico)
message("Mediante estimador sandwich: ", discontinuidad_robust)
}
# Aplicamos chow_dummy a cada transición de periodo
aux1 <- chow_dummy(df_3269, df_3271, mod3_restr, mod3_unrestr, significance = 0.01)
aux2 <- chow_dummy(df_3271, df_3273, mod3_restr, mod3_unrestr, significance = 0.01)
aux3 <- chow_dummy(df_3273, df_3277, mod3_restr, mod3_unrestr, significance = 0.01)
aux4 <- chow_dummy(df_3277, df_3279, mod3_restr, mod3_unrestr, significance = 0.01)
aux5 <- chow_dummy(df_3279, df_3281, mod3_restr, mod3_unrestr, significance = 0.01)
#hay una discontinuidad en aux2 al 0.05 pero no al 0.01
#hay una discontinuidad en aux4
#comprobamos la homocedasticidad
aux1$Homoscedastico
aux2$Homoscedastico
aux3$Homoscedastico #Heteroskedastico
aux4$Homoscedastico #Heteroskedastico
aux5$Homoscedastico
#-----------------Visualización del contraste de hipótesis----------------
#Creamos una tabla con todos los resultados de los test max-t
#indicamos a que periodo corresponde cada contraste
#cada periodo implica una transición. periodo 1 es la transicion entre
#los datos del posteletoral y el barómetro de enero
aux1$maxt_robust <- within(aux1$maxt_robust, {periodo <- 1})
aux2$maxt_robust <- within(aux2$maxt_robust, {periodo <- 2})
aux3$maxt_robust <- within(aux3$maxt_robust, {periodo <- 3})
aux4$maxt_robust <- within(aux4$maxt_robust, {periodo <- 4})
aux5$maxt_robust <- within(aux5$maxt_robust, {periodo <- 5})
#fusionamos
bind_rows(aux1$maxt_robust, aux2$maxt_robust, aux3$maxt_robust, aux4$maxt_robust, aux5$maxt_robust) %>%
mutate(periodo = factor(periodo,
levels= 1:5,
labels = c("Enr", "Feb", "Mar", "Abr", "May")
),
facet = `Parámetro` %>%
#hay que cambiar las formulas de las etiquetas. solo ejemplo
#https://rstudio-pubs-static.s3.amazonaws.com/136237_170402e5f0b54561bf7605bdea98267a.html
#to write powers like 2^3 --> 2^{3}
factor(levels = unique(aux1$maxt_robust$`Parámetro`),
labels = c("tau", "tau*beta[1]",
"tau*beta[2]", "tau*beta[3]")
)
) %>%
ggplot(aes(x = periodo, y = Beta, group =  `Parámetro`)) +
geom_line() +
geom_point() +
geom_errorbar(aes(ymin=`IC inferior`, ymax=`IC superior`, width = .1)) +
geom_hline(yintercept = 0, colour = "red", linetype = "dashed") +
geom_vline(xintercept = 3.5, colour = "darkblue", linetype = "dotted", size = 1) +
facet_wrap(.~facet, scales = "free", labeller = label_parsed)
predictions <- function(..., significance = 0.99){
aux <- list(...)
pooled <- list()
for (i in seq_len(length(aux)-1)){
pre <- aux[[i]]
post <- aux[[i+1]]
pooled[[i]] <- bind_rows(pre, post) %>%
mutate(breakpoint = case_when(Periodo == min(Periodo) ~ "Antes",
Periodo == max(Periodo) ~ "Después") %>%
factor()
)
}
df <<- pooled %>%
map(~lmrob(eval_pres ~ breakpoint*ns(ideol_GMC, 3) + man + higher_educ + welloff,
data= .,
weights = PESO))  %>%
map(~ggpredict(., c("ideol_GMC[all]", "breakpoint"), ci.lvl = significance)) %>%
map(~as_tibble(.))
for (i in seq_along(df)){
df[[i]] <<- df[[i]] %>%
mutate(transition = case_when(i == 1 ~ "Noviembre-Enero",
i == 2 ~ "Enero-Febrero",
i == 3 ~ "Febrero-Marzo ",
i == 4 ~ "Marzo-Abril",
i == 5 ~ "Abril-Mayo",
TRUE ~ "Ampliar el script") %>%
factor(levels = c("Noviembre-Enero",
"Enero-Febrero",
"Febrero-Marzo ",
"Marzo-Abril",
"Abril-Mayo",
"Ampliar el script")
)
)
}
df <- bind_rows(df)
rm(pre, post, aux)
salida <- list(df = df, pooled = pooled)
return(salida)
}
#Función para transformar las muestras pooled de forma que agrupamos los datos por
#valores de ideologia y valoración presidente y teniendo en cuenta los pesos
#determinamos el tamaño relativo de los individuos de las muestras que ocupan
#cada posición
muestra_pooled <- function(data){
sample <- data %>%
select(eval_pres, ideol_GMC, PESO, breakpoint) %>%
arrange(eval_pres,ideol_GMC,breakpoint) %>%
group_by(breakpoint,eval_pres, ideol_GMC) %>%
summarise(size=sum(PESO)) %>%
ungroup() %>%
mutate(prop = size/sum(size)*100) %>%
rename( predicted=eval_pres ,
x=ideol_GMC,
group = breakpoint) %>%
select(-size)
return(sample)
}
tmp <- predictions(df_3269, df_3271, df_3273, df_3277, df_3279, df_3281)
datos_muestra <- map(tmp$pooled, muestra_pooled)
#-----------------Visualización------------------------------------------------
tmp$df %>%
ggplot(aes(x=x, y=predicted, group = group, color= group))+
geom_line() +
geom_ribbon(aes(ymin= conf.low, ymax=conf.high, fill=group), alpha= .3, colour=NA)+
guides(color = FALSE,
size = FALSE)+
theme(legend.title = element_blank())+
facet_wrap(~transition)+
theme(legend.position = c(0.85, 0.25)
,legend.background = element_rect(fill = "white", colour = NA))
